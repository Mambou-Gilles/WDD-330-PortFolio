<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>wdd 330: Week 05 | Portfolio Home Page</title>
    <link rel="stylesheet" href="styles/main.css">
</head>

<body>
  
    <header>
        <h1 id="header-title">Elie Gilles Mambou</h1>
    </header>
    
    <main>
        <h2 id="main-h1">WDD 330: Portfolio Week 5</h2><br>
        
        <ul>
            <li><a href="#note"> My Notes</a></li>
            <li><a href="#quiz"> Ninja Quiz</a></li>
            <li><a href="#question">Questions</a></li>
        </ul>
         
        <h2 id="note">My Notes: Chapter 11 & 13 "JAVASCRIPT: NOVICE TO NINJA, 2ND EDITION"</h2>
        

<h2>Chapter 11: Further Functions from "JAVASCRIPT: NOVICE TO NINJA, 2ND EDITION"</h2>
<p>In JavaScript, functions are first-class objects, which means they can be passed around in the same way as every other value. They can have their own properties and methods, as well as accepting other functions as parameters and being returned by other functions. This makes them a very flexible tool to work within JavaScript, and there are a variety of techniques and patterns that can be used to make the code cleaner.</p>

<h3>Call and Apply Methods</h3>
<p>The call() method can be used to set the value of this inside a function to an object that is provided as the first argument.</p>
<pre>
function sayHello(){
  return `Hello, my name is ${ this.name }`;
}
const clark = { name: 'Clark' };
const bruce = { name: 'Bruce' };

sayHello.<strong>call</strong>(clark);
&lt;&lt; 'Hello, my name is Clarke'

sayHello.<strong>call</strong>(bruce);
&lt;&lt; 'Hello, my name is Bruce'
</pre>

<h3>Memoization</h3>
<p>s an optimization technique that speeds up applications by storing the results of expensive function calls and returning the cached result when the same inputs occur again.</p>
<pre>
function square(x){
  square.cache = square.cache || {};
  if (!square.cache[x]) {
    square.cache[x] = x*x;
  }
  return square.cache[x]
}

square(3);
&lt;&lt; 9

square(-11);
&lt;&lt; 121

square.cache;
&lt;&lt; {"3": 9, "-11": 121}</pre>

<h3>Immediately Invoked Function Expressions</h3>
<p>An Immediately Invoked Function Expression is invoked as soon as it’s defined. This is easily achieved by placing parentheses at the end of the function definition</p>
<pre>
(function(){
  const temp = 'World';
  console.log(`Hello ${temp}`);
})();
&lt;&lt;'Hello World'</pre>

<h3>Recursive Functions</h3>
<p>A recursive function is one that invokes itself until a certain condition is met. It’s a useful tool to use when iterative processes are involved</p>
<pre>
function factorial(n) {
  if (n === 0) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}
</pre>
<h3><a href="https://www.sitepoint.com/premium/books/javascript-novice-to-ninja-2nd-edition/read/11">Callback Hell</a></h3>
<pre>
login(userName, function(error,user) {
  if(error){
    throw error;
  } else {
    getPlayerInfo(user.id, function(error,info){
    if(error){
      throw error;
    } else {
      loadGame(info, function(error,game) {
      if(error){
          throw error;
        } else {
        // code to run game
        }
      });
    }
    });
  }
});
</pre>
<h3>Promises</h3>
<p> A promise represents the future result of an asynchronous operation. Promises don't do anything that can't already be achieved using callbacks, but they help simplify the process and avoid the convoluted code that can result from using multiple callbacks</p>
<p>When a promise is created, it calls an asynchronous operation and is then said to be pending. It remains in this state while the operation is taking place.
     At this stage, the promise is said to be unsettled. Once the operation has been completed, the promise is said to have been settled. 
     A settled promise can result in two different outcomes:</p>
<ul>
<li>Resolved ― the asynchronous operation was completed successfully.</li>

<li>Rejected ― the asynchronous operation didn’t work as expected, wasn't successfully completed, or resulted in an error.</li></ul>

<p>Both these outcomes will return any relevant data, and you can take the appropriate action based on the outcome of the promise.</p>
<h3>Creating A Promise</h3>
<p>A promise is created using a constructor function. This takes a function called an executor as an argument. The executor initializes the promise and starts the asynchronous operation. It also accepts two functions as arguments: the resolve() function is called if the operation is successful, and the reject() function is called if the operation fails</p>
<pre>
const promise = new Promise( (resolve, reject) => {
  // initialization code goes here
  if (success) {
    resolve(value);
  } else {
    reject(error);
  }
});
</pre>
<h3>Dealing With A Settled Promise</h3>
<p>Once a promise has been settled, the then() method can be used to deal with the outcome. This method accepts two arguments. The first is a fulfillment function that’s called when the promise is resolved.<br>
The second argument is a rejection function that’s called if the promise is rejected.</p>
<pre>
promise.then( result => console.log(`Yes! I rolled a ${result}`), result => console.log(`Drat! ... I rolled a ${result}`) );</pre>
<p>Alternatively, the catch() method can be used to specify what to do if the operation fails instead:</p>
<pre>promise.catch( result => console.log(`Drat! ... I rolled a ${result}`));</pre>
<p>Below is an example of the then() and catch() method chained together:</p>
<pre>
const dice = {
  sides: 6,
  roll() {
    return Math.floor(this.sides * Math.random()) + 1;
  }
}

console.log('Before the roll');

const roll = new Promise( (resolve,reject) => {
  const n = dice.roll();
  if(n > 1){
    setTimeout(()=>{resolve(n)},n*200);
  } else {
    setTimeout(()=>reject(n),n*200);
  }
});

roll.then(result => console.log(`I rolled a ${result}`) )
.catch(result => console.log(`Drat! ... I rolled a ${result}`) );

console.log('After the roll');
</pre>
<h3>Functions That Return Functions</h3>
<pre>
function returnHello() {
  console.log('returnHello() called');
  return function() {
    console.log('Hello World!');
  }
}
</pre>
<h3>Closures</h3>
<p>In JavaScript, a closure is a function that references variables in the outer scope from its inner scope. The closure preserves the outer scope inside its inner scope.</p>
<p>To learn about closures, go to this link <a href="https://www.javascripttutorial.net/javascript-closure/"> "Learn Javascript Closures"</a></p>

<h2>Chapter 13: AJAX from "JAVASCRIPT: NOVICE TO NINJA, 2ND EDITION"</h2>
<p>The term AJAX stands fors Asynchronous, Javascript, XML</p>
<h2>Fetch API</h2>
<h3>Basic Usage</h3>
<p>The Fetch API provides a global fetch() method that only has one mandatory argument, which is the URL of the resource you wish to fetch.</p>
<pre>
fetch('https://example.com/data')
.then( // code that handles the response )
.catch( // code that runs if the server returns an error )
</pre>
<h3>Response Interface</h3>
<pre>
const url = 'https:example.com/data';

fetch(url)
.then((response) => {
  if(response.ok) {
    return response;
  }
  throw Error(response.statusText);
  })
.then( response => // do something with response )
.catch( error => console.log('There was an error!') )
</pre>
<h3>Redirects</h3>
<p>The redirect() method can be used to redirect to another URL. It creates a new promise that resolves to the response from the redirected URL</p>
<pre>
fetch(url)
.then( response => response.redirect(newURL)); // redirects to another URL
.then( // do something else )
.catch( error => console.log('There was an error: ', error))
</pre>
<h3>Text Responses</h3>
<p>The text() method takes a stream of text from the response, reads it to completion and then returns a promise that resolves to a USVSting object that can be treated as a string in JavaScript.</p>
<pre>
fetch(url)
.then( response => response.text() ); // transforms the text stream into a JavaScript string
.then( text => console.log(text) )
.catch( error => console.log('There was an error: ', error))
</pre>
<h3>File Responses</h3>
<p>The blob() method is used to read a file of raw data, such as an image or a spreadsheet. Once it has read the whole file, it returns a promise that resolves with a blob object.</p>
<pre>
fetch(url)
.then( response => response.blob() ); // transforms the data into a blob object
.then( blob => console.log(blob.type) )
.catch( error => console.log('There was an error: ', error))
</pre>
<h3>Request Interface</h3>
<p>Request objects are created using the Request() constructor, and include the following properties:</p>
<ul>
<li>url – The URL of the requested resource (the only property that is required).</li>
<li>method – a string that specifies which HTTP method should be used for the request. By default, this is 'GET'.</li>
<li>headers – This is a Headers object (see later section) that provides details of the request's headers.</li>
<li>mode – Allows you to specify if CORS is used or not. CORS is enabled by default.</li>
<li>cache – Allows you to specify how the request will use the browser's cache. For example, you can force it to request a resource and update the cache with the result, or you can force it to only look in the cache for the resource.</li>
<li>credentials – Lets you specify if cookies should be allowed with the request.
redirect</li></ul>
<pre>
const request = new Request('https://example.com/data', {
  method: 'GET',
  mode: 'cors',
  redirect: 'follow',
  cache: 'no-cache'
});
fetch(request)
.then( // do something with the response )
.catch( // handle any errors)
</pre>
<p>Alternatively, you can enter the URL and object directly as arguments of the fetch() method, without having to create a Request object</p>
<pre>
fetch('https://example.com/data', {
method: 'GET',
mode: 'cors',
redirect: 'follow',
cache: 'no-cache'
})
.then( // do something with the response )
.catch( // handle any errors)
</pre>
<h3>Headers Interface</h3>
<p>HTTP headers are used to pass on any additional information about a request or response.</p>
<pre>
const headers = new Headers();
</pre>
<p>The constructor function can be provided with an optional argument containing any initial header values:</p>
<pre>
const headers = new Headers({ 'Content-Type': 'text/plain', 'Accept-Charset' : 'utf-8', 'Accept-Encoding':'gzip,deflate' })</pre>
<p>
A Headers object includes the following properties and methods that can be used to access information about the headers, as well as edit the header information:
<ul>
<li>has() – Can be used to check if the headers object contains the header provided as an argument.</li>
<li>get() - Returns the value of the header provided as an argument</li>
<li>set() – Can be used to set a value of an already existing header, or create a new header with the value provided as an argument if it does not already exist.</li>
<li>append() – Adds a new header to the headers object.</li>
<li>delete() – Removes the header provided as an argument.</li>
<li>keys(), values() and entries() – Iterators that can be used to iterate over the headers key, values or entries (key and value pairs).</li>
</ul>
<pre>
headers.has('Content-Type');
    &lt;&lt; true

headers.get('Content-Type');
    &lt;&lt; 'text/plain'

headers.set('Content-Type', 'application/json');

headers.append('Accept-Encoding','gzip,deflate');

headers.delete('Accept-Encoding')

for(const entry of headers.entries(){
    console.log(entry);
    }
    &lt;&lt; [ 'Content-Type', 'application/json' ]
     </pre>
<h3>FormData</h3>
<p>The Fetch API includes the FormData interface, which makes it much easier to submit information in forms using Ajax.</p>
<pre>
A FormData instance is created using a constructor function:
const data = new FormData();
</pre>

     
      
    <h2 id="quiz">Ninja Quiz Practice</h2>
    <p> In the links below you will go to our practice link </p>
       <a href="quiz/ajax.html">Number Fact & Chuck Norris Fact</a><br>
        <a href="quiz/index11.html">Chapter 11 Further Function Quiz Ninja</a><br>
        <a href="quiz/index13.html">Chapter 13 AJAX Quiz Ninja</a>

            <h2 id="question">Question:</h2>
            <p>No questions at moment</p>
            
    </main>
    <footer>
          &copy; <span id="year"></span> <!-- <script>document.write(new Date().getFullyear());</script> -->  | Elie Gilles Mambou | Utah | 
         <a href="https://www.byui.edu/online" id="footer-link">BYU Online Learning</a>
         <p id="update">       </p>
    </footer>
    <script src="scripts/main.js"></script>
    
</body>

</html>
© 2021 GitHub, Inc.
Terms
Privacy
